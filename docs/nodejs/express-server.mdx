---
title: Express Server Creation
description: Understanding the different ways to create and start an Express server
---

## Two Ways to Create an Express Server

Express provides two approaches to create and start a server. Both are functionally equivalent, but serve different purposes.

---

## Method 1: `app.listen()` (Simple)

The most common approach for straightforward applications:

```javascript
import express from 'express';

const app = express();

// Configure routes and middleware
app.get('/', (req, res) => res.send('Hello World'));

// Start the server
app.listen(3000, () => {
  console.log('Server running on port 3000');
});
```

This is a convenience method. Under the hood, `app.listen()` does exactly what Method 2 does:

```javascript
// What app.listen() actually does internally
http.createServer(app).listen(port, callback);
```

---

## Method 2: `http.createServer()` (Explicit)

The explicit approach using Node's built-in `http` module:

```javascript
import express from 'express';
import http from 'http';

const app = express();

// Configure routes and middleware
app.get('/', (req, res) => res.send('Hello World'));

// Create server explicitly
const server = http.createServer(app);

// Start the server
server.listen(3000, () => {
  console.log('Server running on port 3000');
});
```

---

## When to Use Each Method

| Scenario | Recommended Method |
|----------|-------------------|
| Simple REST API | `app.listen()` |
| Basic web application | `app.listen()` |
| WebSocket integration | `http.createServer()` |
| HTTPS server | `http.createServer()` |
| Multiple protocols | `http.createServer()` |
| Server event handling | `http.createServer()` |

---

## Use Cases for Explicit Server Creation

### 1. WebSocket Integration (Socket.IO)

Socket.IO requires direct access to the HTTP server instance:

```javascript
import express from 'express';
import http from 'http';
import { Server } from 'socket.io';

const app = express();
const server = http.createServer(app);
const io = new Server(server);

// Express routes
app.get('/', (req, res) => {
  res.sendFile('index.html');
});

// Socket.IO events
io.on('connection', (socket) => {
  console.log('User connected:', socket.id);
  
  socket.on('message', (data) => {
    io.emit('message', data);
  });
});

// Must use server.listen(), not app.listen()
server.listen(3000, () => {
  console.log('Server with WebSocket running on port 3000');
});
```

If you used `app.listen()` here, Socket.IO wouldn't be attached to the correct server instance.

### 2. HTTPS Server

Creating an HTTPS server requires the `https` module:

```javascript
import express from 'express';
import https from 'https';
import fs from 'fs';

const app = express();

const options = {
  key: fs.readFileSync('private-key.pem'),
  cert: fs.readFileSync('certificate.pem')
};

// Create HTTPS server
const server = https.createServer(options, app);

app.get('/', (req, res) => {
  res.send('Secure connection!');
});

server.listen(443, () => {
  console.log('HTTPS server running on port 443');
});
```

### 3. Running Both HTTP and HTTPS

Serve the same Express app over both protocols:

```javascript
import express from 'express';
import http from 'http';
import https from 'https';
import fs from 'fs';

const app = express();

app.get('/', (req, res) => {
  res.send('Works on both HTTP and HTTPS!');
});

// HTTP server (redirect to HTTPS in production)
const httpServer = http.createServer(app);

// HTTPS server
const httpsServer = https.createServer({
  key: fs.readFileSync('private-key.pem'),
  cert: fs.readFileSync('certificate.pem')
}, app);

httpServer.listen(80, () => console.log('HTTP on port 80'));
httpsServer.listen(443, () => console.log('HTTPS on port 443'));
```

### 4. Server Event Handling

Access server events like connection errors or upgrades:

```javascript
import express from 'express';
import http from 'http';

const app = express();
const server = http.createServer(app);

// Handle server-level events
server.on('error', (err) => {
  if (err.code === 'EADDRINUSE') {
    console.error('Port already in use');
  }
});

server.on('connection', (socket) => {
  console.log('New TCP connection');
});

server.on('upgrade', (req, socket, head) => {
  // Handle WebSocket upgrade requests manually
});

server.listen(3000);
```

### 5. Graceful Shutdown

Properly close the server and all connections:

```javascript
import express from 'express';
import http from 'http';

const app = express();
const server = http.createServer(app);

app.get('/', (req, res) => res.send('Hello'));

server.listen(3000);

// Graceful shutdown
process.on('SIGTERM', () => {
  console.log('Shutting down gracefully...');
  
  server.close(() => {
    console.log('Server closed');
    process.exit(0);
  });

  // Force close after timeout
  setTimeout(() => {
    console.error('Forcing shutdown');
    process.exit(1);
  }, 10000);
});
```

---

## The Return Value Difference

Both methods return a `http.Server` instance:

```javascript
// Method 1: Returns the server
const server = app.listen(3000);
console.log(server instanceof http.Server); // true

// Method 2: You already have the server reference
const server = http.createServer(app);
server.listen(3000);
```

With `app.listen()`, you can still access the server for things like graceful shutdown:

```javascript
const server = app.listen(3000);

server.close(() => {
  console.log('Server closed');
});
```

---

## Quick Reference

| Aspect | `app.listen()` | `http.createServer(app)` |
|--------|----------------|--------------------------|
| Lines of code | Fewer | More |
| Server access | Via return value | Direct reference |
| WebSocket support | Awkward | Natural |
| HTTPS | Not possible | Supported |
| Complexity | Lower | Higher |
| Use case | Simple apps | Advanced setups |

---

## Best Practice

Start with `app.listen()` for simplicity. Switch to `http.createServer()` when you need:

- WebSocket integration
- HTTPS support
- Multiple server instances
- Access to low-level server events

