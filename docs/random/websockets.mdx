---
title: WebSockets
description: Understanding real-time bidirectional communication between clients and servers
---

## What Are WebSockets?

WebSockets provide a **persistent, bidirectional communication channel** between a client (typically a browser) and a server. Unlike HTTP's request-response model, WebSockets allow both parties to send messages at any time without waiting for a response.

Think of HTTP as sending letters back and forth, while WebSockets are like having an open phone call where either side can speak whenever they want.

---

## HTTP vs WebSockets

| Aspect | HTTP | WebSockets |
|--------|------|------------|
| Communication | One-way (client requests, server responds) | Bidirectional (both can send anytime) |
| Connection | Stateless (new connection per request) | Persistent (single open connection) |
| Overhead | High (headers sent with every request) | Low (minimal framing after handshake) |
| Data Format | Text-based, verbose headers | Lightweight, binary-friendly |
| Use Case | Static content, REST APIs | Real-time apps, live data |

---

## The WebSocket Lifecycle

### 1. The Handshake (HTTP Upgrade)

WebSocket connections begin as regular HTTP requests. The client sends a special request asking to "upgrade" the connection:

```http
GET /chat HTTP/1.1
Host: example.com
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==
Sec-WebSocket-Version: 13
```

Key headers:
- **`Upgrade: websocket`** signals the intent to switch protocols
- **`Connection: Upgrade`** confirms the connection should be upgraded
- **`Sec-WebSocket-Key`** is a random base64 value for security validation

### 2. Server Accepts the Upgrade

If the server supports WebSockets and agrees to upgrade, it responds with:

```http
HTTP/1.1 101 Switching Protocols
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo=
```

The `101 Switching Protocols` status code confirms the protocol change. From this point, HTTP is no longer used on this connection.

### 3. Full-Duplex Communication

Once established, the WebSocket connection is **full-duplex**:

- Both client and server can send messages independently
- No request-response cycle required
- Messages are framed with minimal overhead (as little as 2 bytes for small messages)
- The connection persists until explicitly closed by either party

---

## Common Use Cases

WebSockets excel in scenarios requiring real-time data flow:

| Application | Why WebSockets? |
|-------------|-----------------|
| Chat applications | Instant message delivery without polling |
| Multiplayer games | Low-latency player state synchronization |
| Live dashboards | Stock tickers, analytics, monitoring |
| Collaborative tools | Real-time document editing (Google Docs style) |
| IoT communication | Continuous device-to-server data streams |
| Notifications | Push updates without client polling |

---

## Why Node.js Excels at WebSockets

Node.js is particularly well-suited for WebSocket applications:

1. **Event-driven architecture** handles thousands of concurrent connections efficiently
2. **Non-blocking I/O** prevents one slow connection from blocking others
3. **Single-threaded event loop** reduces context-switching overhead
4. **Native TCP/HTTP support** provides low-level networking capabilities
5. **Rich ecosystem** with battle-tested libraries like `ws` and `socket.io`

---

## Implementation Approaches

### Using the `ws` Library (Low-Level)

The `ws` library provides a minimal, standards-compliant WebSocket implementation close to the raw protocol.

```bash
npm install ws
```

**Server:**

```javascript
const WebSocket = require('ws');

const wss = new WebSocket.Server({ port: 8080 });

wss.on('connection', (socket) => {
  console.log('Client connected');

  // Handle incoming messages
  socket.on('message', (data) => {
    console.log('Received:', data.toString());
    socket.send('Message received!');
  });

  // Handle disconnection
  socket.on('close', () => {
    console.log('Client disconnected');
  });

  // Handle errors
  socket.on('error', (err) => {
    console.error('WebSocket error:', err);
  });
});

console.log('WebSocket server running on ws://localhost:8080');
```

**Client (Browser):**

```javascript
const socket = new WebSocket('ws://localhost:8080');

socket.onopen = () => {
  console.log('Connected to server');
  socket.send('Hello from client!');
};

socket.onmessage = (event) => {
  console.log('Server says:', event.data);
};

socket.onclose = () => {
  console.log('Disconnected from server');
};

socket.onerror = (error) => {
  console.error('WebSocket error:', error);
};
```

### Using Socket.IO (High-Level)

Socket.IO provides a higher-level abstraction with additional features like automatic reconnection, rooms, and fallback transports.

```bash
npm install socket.io
```

**Server:**

```javascript
const http = require('http');
const express = require('express');
const { Server } = require('socket.io');

const app = express();
const server = http.createServer(app);
const io = new Server(server);

io.on('connection', (socket) => {
  console.log('User connected:', socket.id);

  // Listen for custom events
  socket.on('chat message', (msg) => {
    console.log('Message:', msg);
    
    // Broadcast to all connected clients
    io.emit('chat message', msg);
  });

  // Join a room
  socket.on('join room', (room) => {
    socket.join(room);
    console.log(`${socket.id} joined room: ${room}`);
  });

  // Handle disconnection
  socket.on('disconnect', () => {
    console.log('User disconnected:', socket.id);
  });
});

server.listen(3000, () => {
  console.log('Server running on http://localhost:3000');
});
```

**Client:**

```html
<script src="/socket.io/socket.io.js"></script>
<script>
  const socket = io();

  // Listen for messages
  socket.on('chat message', (msg) => {
    console.log('Message from server:', msg);
  });

  // Send a message
  socket.emit('chat message', 'Hello server!');

  // Join a room
  socket.emit('join room', 'general');
</script>
```

---

## `ws` vs Socket.IO

| Feature | ws | Socket.IO |
|---------|-----|-----------|
| Protocol | Pure WebSocket | Custom protocol over WebSocket |
| Fallback transports | No | Yes (long-polling, etc.) |
| Auto-reconnection | Manual | Built-in |
| Rooms and namespaces | Manual | Built-in |
| Broadcasting | Manual loop | One-liner (`io.emit()`) |
| Binary support | Yes | Yes |
| Bundle size | Minimal | Larger (includes client library) |
| Browser support | Modern browsers | Broader (with fallbacks) |

**Choose `ws` when:**
- You need maximum performance and minimal overhead
- You're building a simple WebSocket service
- Clients are guaranteed to support WebSockets

**Choose Socket.IO when:**
- You need rooms, namespaces, or broadcasting
- You want automatic reconnection handling
- You need fallback support for older browsers

---

## Connection States

WebSocket connections have four states:

| State | Value | Description |
|-------|-------|-------------|
| `CONNECTING` | 0 | Connection is being established |
| `OPEN` | 1 | Connection is open and ready |
| `CLOSING` | 2 | Connection is closing |
| `CLOSED` | 3 | Connection is closed |

```javascript
const socket = new WebSocket('ws://localhost:8080');

console.log(socket.readyState); // 0 (CONNECTING)

socket.onopen = () => {
  console.log(socket.readyState); // 1 (OPEN)
};
```

---

## Best Practices

1. **Handle disconnections gracefully** with reconnection logic
2. **Implement heartbeats** (ping/pong) to detect stale connections
3. **Use secure WebSockets (`wss://`)** in production
4. **Validate and sanitize** all incoming messages
5. **Set connection limits** to prevent resource exhaustion
6. **Consider message queuing** for reliability in critical applications

